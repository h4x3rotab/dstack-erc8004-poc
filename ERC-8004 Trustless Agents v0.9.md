
## EIP 8004 Original Draft

TEE Key Registry

If your agent runs in a TEE, instead of requiring frequent on-chain transactions for each validation request and response, a validating smart contract can verify once (through attestations) that a given ECDSA key has been generated by a TEE running a specific container image. Once verified, the public key is placed on-chain. From that moment onwards, anyone who trusts the container image and the TEE vendor (e.g., Intel SGX, AWS Nitro) can use the public key to encrypt information or verify signatures, without further interaction with ERC-8004 contracts.

When the TEE Key Registry is deployed, the identityRegistry address is passed to the constructor and is visible by calling getIdentityRegistry(), as described above.

Key Registration Flow

1. The agent generates its own TEE attestation document
2. The agent server uses local computation or a proving cloud to prove the attestation verification process
3. In the proof, the code measurement (hash of the running code) and the agent's secp256k1 public key are public input
4. The proof is submitted on-chain and verified by a whitelisted zkVerifier contract
5. Upon successful verification, the zkVerifier calls the TEE Key Registry's addKey function
6. The TEE Key Registry records the code measurement and secp256k1 public key associated with the agent

Notes:
The attestation verification logic in the zkVerifier contract MUST be open source and pre-audited
ERC-8004 contract maintainers are responsible for adding and removing trusted zkVerifier contracts
It is the agent's responsibility to disclose its source code and provide guidance on verifying its code measurement. Reputation around codebases and container images is not managed by ERC-8004;
Contract Structure

```
contract TEERegistry {
    struct ZKVerifier {
        bytes32 teeArch;
        // ... more verifier metadata
    }
    
    mapping(address => ZKVerifier) public zkVerifiers;
    
    struct Key {
        bytes32 teeArch;
        bytes32 codeMeasurement;
        bytes pubkey;
        string imageUri;
        address zkVerifier;
    }
    
    mapping(uint256 => Key[]) public keys;
    
    event ZKVerifierAdded(address indexed verifier, bytes32 vendor);
    event ZKVerifierRemoved(address indexed verifier);
    event KeyAdded(
        uint256 indexed agentId,
        bytes32 teeArch,
        bytes32 codeMeasurement,
        address pubkey,
        string imageUri,
        address zkVerifier
    );

    event KeyRemoved(
        uint256 indexed agentId,
        address pubkey
    );
    
    function addZKVerifier(address verifier, bytes32 vendor) external onlyOwner;
    function removeZKVerifier(address verifier) external onlyOwner;
    
    function addKey(
        uint256 agentId,
        bytes32 teeArch,
        bytes32 codeMeasurement,
        address pubkey,
        string calldata imageUri,
        address zkVerifier,
        bytes calldata zkProof
    ) external;
    
    function removeKey(
        uint256 agentId,
        address pubkey
    ) external;
    
    function getKeys(uint256 agentId) external view returns (Key[] memory);
    function getKey(uint256 agentId, address pubkey) external view returns (Key memory);
    function isZKVerifier(address verifier) external view returns (bool);
}
```

The addKey and removeKey functions are callable only by the owner or one of the operators of the agent identified by agentId:

teeArch: Identifies the TEE architecture (e.g., Intel SGX, AWS Nitro, AMD SEV)
codeMeasurement: Cryptographic hash of the code running in the TEE
pubkey: The secp256k1 public key generated within the TEE
imageUri: URI pointing to the container image or code specification
zkVerifier: Address of the zero-knowledge verifier contract that validated this attestation
